% engine=luatex

\usemodule[t][presentation]
\usemodule[mathsets]

\environment macros

\setupTitle
  [title={A graphical model for sequential teams},
   author={Aditya Mahajan and Sekhar Tatikonda 
      \crlf Dept of Electrical Engineering \crlf
           Yale University},
   date={Presented at: ConCom Workshop, June 27, 2009}]

\starttext

\placeTitle


\Interlude A glimpse of the result

\SlideTitle Structural results in sequential teams

\startitemize 
  \head Example: MDP (Markov decision process)

    \startitemize
      \item Controlled MC:
        $\PR{x_t | x_1, \dots, x_{t-1}, u_1, \dots, u_{t-1}} = 
        \PR{x_t | x_{t-1}, u_{t-1}}$
      \item Controller: \important{$u_t = g_t(x_1, \dots, x_t, u_1, \dots,
        u_{t-1})$}
      \item Reward:  $r_t = ρ_t(x_t, u_t)$
      \item Objective: Maximize $\displaystyle \EXP{\sum_{t=1}^T R_t}$
    \stopitemize

  \head Structural results

    \startitemize
      \item Without loss of optimality, \important{$u_t = g_t(x_t)$}
    \stopitemize

\stopitemize

\IncludePicture
  [horizontal]
  [fig-mdp]
  {Graphically \unknown\ original}

\IncludePicture
  [horizontal]
  [fig-mdp]
  [page=3]
  {Graphically \unknown\ structural results}

\SlideTitle Structural results in sequential teams

\startitemize
  \head Example: real-time source coding
    
    \startitemize
      \item Source: First order Markov source $\{x_t$, $t=1,\dots\}$ 
      \item Real-time source coder: 
        \important{$y_t = c_t(x_1, \dots, x_t, y_1, \dots, y_{t-1})$}
      \item Finite memory decoder: $\hat x_t = g_t(y_t, m_{t-1})$
      \item \hphantom{Finite memory decoder} $m_{t} = l_t(y_t, m_{t-1})$
      \item Cost: $d_t = ρ_t(x_t, \hat x_t)$
    \stopitemize

\stopitemize

\startitemize[paper]
  \item Hans S.\ Witsenhausen, 
    \emph{On the structure of real-time source coders}, \crlf
    Bell Systems Technical Journal, 
    vol 58, no 6, pp 1437-1451, July-August 1979
\stopitemize

\startitemize
  \head Structural Results

    \startitemize
      \item Without loss of optimality, \important{$y_t = c_t(x_t, m_{t-1})$}
    \stopitemize
\stopitemize

\IncludePicture
  [horizontal]
  [fig-rt]
  {Graphically \unknown\ original}

\IncludePicture
  [horizontal]
  [fig-rt]
  [page=16]
  {Graphically \unknown\ structural results}


\Interlude \important{The main idea} \\
\switchtobodyfont[20pt] \setupinterlinespace
 \symbol[1]\enspace Represent a sequential team as a directed graph \\
 \symbol[1]\enspace Simplify the graph 

\SlideTitle Sequential teams -- Salient features

\startitemize
  \item A team is \important{sequential} \emph{if and only if} there exists
    a \important{partial order} between the system variables.

  \item There is \emph{no loss of optimality} in restricting attention to
    \important{non-randomizing decision makers}

  \item \emph{Data} available at a DM can be \emph{ignored} if it is 
    \important{independent} of the future rewards \important{conditioned} on
    other data at the DM

  \item Variables \important{functionally determined} from the data available at
    a DM can be assumed to be \emph{observed} at the DM.

\stopitemize

\SlideTitle Graphical models -- Salient features

\startitemize
  \item Any \emph{partial order} gives rise to a \important{DAG (Directed
    Acyclic Graph)}

  \item A DAFG can be used to \emph{efficiently check} for
    \important{conditional independence} using \emph{d-separation}

  \item A DAFG can be used to \emph{efficiently check} for
    \important{conditional independence with deterministic nodes} using
    \emph{D-separation}
    
\stopitemize

\Interlude {\switchtobodyfont[24pt]
Match between features of sequential teams and graphical models \\
 \important{The rest is a matter of details \unknown} \endgraf}

\SlideTitle The model

\startitemize
  \head Components of a sequential team

    \startitemize[unpacked]

      \item A set \important{$N$} of indices of \emph{system variables} 
        $\{\important{X_n}, n \in N\}$. \crlf
       Finite sets $\{\important{\ALPHABET X_n}$, $n \in N\}$ of 
        \emph{state spaces} of $X_n$
        \vskip -.5\baselineskip
        \startitemize[packed]
          \item $\important{A} \subset N$, \emph{variables generated by DM}
            % \quad \symbol[3]
            % \enspace
          \item \important{$N \setminus A$}, \emph{variables generated \rlap{by
            nature}}
          \item $\important{R} \subset N$, \emph{reward variables}
        \stopitemize


      \item Information sets $\{\important{I_n}$, $n \in N\}$, 
        such that $I_n \subseteq \{1,\dots,n\}$.
        $\ALPHABET I_n = \prod_{i \in I_n} \ALPHABET X_i$

      \item $\important{F_{N\setminus A}} = \{f_n$, $n \in N \setminus A\}$,
        where \important{$f_n$} is a \emph{conditional PMF} $\ALPHABET X_n$
        given $\ALPHABET I_n$

      \item Design: 
        $\important{G_A} = \{g_n$, $n \in A\}$, where \important{$g_n$} is a
        \emph{decision rule} from $\ALPHABET I_n$ to $\ALPHABET X_n$
    \stopitemize

\stopitemize

\SlideTitle The model

\startitemize
  \head Probability measure induced by a design

    \startformula
      P^{G_A}(X_N) = \prod_{n \in N\setminus A} f_n(X_n | I_n) \prod_{n \in A}
      \IND {X_n = g_n (I_n)}
    \stopformula

  \head Optimization problem

    Minimize $\displaystyle \EXP{\sum_{n \in R} X_n}$, where the expectation is
    with respect to $P^{G_A}$.
\stopitemize

% \SlideTitle Generality of the Model
% 
% \startitemize
%   \head Witsenhausen's intrinsic model 
% 
%     \startitemize[paper,unpacked]
%       \item Hans S.\ Witsenhausen, 
%         \emph{On information structures, feedback and causality}, \crlf
%         SIAM Journal of Control, 9 (1971), pp.~149-160. \crlf
%         \null \hfill \important
%           {partial order $\iff$ sequentiality}
% 
%     %  \item Hans S.\ Witsenhausen, 
%     %    \emph{The intrinsic model for stochastic control: Some open problems}
%     %    \crlf
%     %    Lecture Notes in Economics and Mathematical Systems, 17 (1975),
%     %    pp~322-335.
%     \stopitemize
% 
%   \head Witsenhausen's sequential control model 
% 
%     \startitemize[paper]
%       \item Hans S.\ Witsenhausen, 
%         \emph{A standard form for sequential stochastic control}, \crlf
%         Math.\ Systems Theory, 7 (1973), pp.~5--11. 
%     \stopitemize
% 
%   \head Witsenhausen's equivalent control model 
% 
%     \startitemize[paper]
%       \item Hans S.\ Witsenhausen, 
%         \emph{Equivalent stochastic control problems}, \crlf
%         Math.\ Controls, Signals and Systems, 1 (1988), pp.~3--11.
%     \stopitemize
% \stopitemize
          
% \startitemize %{{{
%   \head Conditions to check if a multi-stage game or team is
% 
%     \startitemize
%       \item causal
%       \item deadlock free
%       \item sequential
%     \stopitemize
% 
%   \head Properties of such systems
% 
% \stopitemize
% 
% \SlideTitle How to check if a system is sequential \unknown {}
% 
% \startitemize
%   \head The intuitive definition
% 
%     DMs actions or events in nature do not influence order of DM's
%     actions.
% 
%   \head The (informal) formal definition
% 
%     \vskip -1\baselineskip
%     \startitemize
%       \item \emph{Subsystem}: A set of system variables form a subsystem if
%         these variables depend only on other variables in the set.
% 
%       \item \emph{Closure of a DM~$α$:} $\overline {\{α\}}$ is the smallest
%         subsystem containing $α$ (or more precisely, the data observed by~$α$).
% 
%       \item \emph{A binary relation on DMs:} $α \leftarrow β$ iff 
%         $\overline {\{α\}} \subseteq \overline {\{β\}}$.
% 
%       \item $\leftarrow$ is reflexive and transitive $\implies$ a
%         \important{quasi-order}.
% 
%     \stopitemize
% 
%     \startimportant
%       A system is sequential if and only if $\leftarrow$ is a partial order.
%     \stopimportant
% 
% \stopitemize %}}}

\SlideTitle Representation as a graphical model

\startitemize
  \head Directed Acyclic Factor Graph

  \head Nodes

    \startitemize
      \item \emph{Variable node} \important{$n$} $\equiv$ system variable $X_n$
      \item \emph{Factor node} \hskip 1.1em \important{$\tilde n$}
        $\equiv$ conditional PMF $f_n$
        or decision rule $g_n$
    \stopitemize

  \head Edges

    \startitemize
      \item \important{$(i, \tilde n)$}, for each $n \in N$ and $i \in I_n$
      \item \important{$(\tilde n, n)$}, for each $n \in N$
    \stopitemize
      
  \head Acyclic Graph

    \startitemize
      \item Sequential team $\Rightarrow$ partial order on variable nodes 
        $\Rightarrow$ acyclic graph
    \stopitemize
\stopitemize

\SlideTitle Graphical models -- Terminology

\startitemize[packed]
  \head $\PARENTS{n}$
        
    \startitemize
      \item $\{m \,:\, m \CONNECTED n \}$
      \item Parents of a control (factor) node = data observed by controller
    \stopitemize

  \head $\CHILDREN{n}$

    \startitemize
      \item $\{m \,:\, n \CONNECTED m\}$
      \item Children of a control node = control action
    \stopitemize

  \head $\ANCESTORS{n}$
    
    \startitemize
      \item $\{ m \,:\, \exists $ directed path from $m$ to $n \}$
      \item Ancestors of a control node = all nodes that affect the
        data observed 
    \stopitemize

  \head $\DESCENDANTS{n}$ 
    
    \startitemize
      \item $\{ m \,:\, \exists $ directed path from $n$ to $m \}$
      \item Descendants of a control node = all nodes affected by the control
        action
    \stopitemize

\stopitemize

\IncludePicture
  [horizontal]
  [fig-mdp]
  [page=1]
  {Graphical Models --- Example}

\defineoverlay[simpleslides:background:highlight]
              [\useMPgraphic{simpleslides:MP:setup}]%

\unprotect
\startuseMPgraphic{simpleslides:MP:setup}
\ifconditional \simpleslidesHighlight
  \ifconditional \simpleslidesGrid
	\includeMPgraphic{simpleslides:MP:highlight:grid}
    \ifconditional \simpleslidesSubGrid
      \includeMPgraphic{simpleslides:MP:highlight:subgrid}%
    \fi
  \fi

  save p; path p;
  p := fullsquare xyscaled 
        % The dimensions are divided by 5 rather than 10, since the scale 
        % measures the radius, rather than the diameter.
        (4*OverlayWidth/5, 1.2*OverlayHeight/5)
       shifted
       (5.8*OverlayWidth/10, 9.1*OverlayHeight/10)  ;
  
  \ifcase \simpleslidesShadow \else
  
  save shadow_direction ; pair shadow_direction ;
  shadow_direction =\simpleslidesPictureParameter\c!rulethickness * 
     \ifcase \simpleslidesShadow \or
          (-1,1) \or (1,1) \or (1,-1) \or (-1,-1) \fi ;


  save shadow_thickness ; numeric shadow_thickness ;
  shadow_thickness := 2.7\simpleslidesPictureParameter\c!rulethickness ;

  def shadow_draw = draw enddef ;

  \includeMPgraphic{simpleslides:MP:highligh:shadow}
  \fi

  draw p withcolor \MPcolor{\simpleslidesPictureParameter\c!color} 
       withpen pencircle scaled (\simpleslidesPictureParameter\c!rulethickness);

  label.top(btex \important{Reward nodes} etex, 
            (5.8*OverlayWidth/10, 10.5*OverlayHeight/10)) ;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  p := fullsquare xyscaled 
        % The dimensions are divided by 5 rather than 10, since the scale 
        % measures the radius, rather than the diameter.
        (4.8*OverlayWidth/5, 1.2*OverlayHeight/5)
       shifted
       (5*OverlayWidth/10, 3.7*OverlayHeight/10)  ;
  
  \ifcase \simpleslidesShadow \else
  
  save shadow_direction ; pair shadow_direction ;
  shadow_direction =\simpleslidesPictureParameter\c!rulethickness * 
     \ifcase \simpleslidesShadow \or
          (-1,1) \or (1,1) \or (1,-1) \or (-1,-1) \fi ;


  save shadow_thickness ; numeric shadow_thickness ;
  shadow_thickness := 2.7\simpleslidesPictureParameter\c!rulethickness ;

  def shadow_draw = draw enddef ;

  \includeMPgraphic{simpleslides:MP:highligh:shadow}
  \fi

  draw p withcolor \MPcolor{\simpleslidesPictureParameter\c!color} 
       withpen pencircle scaled (\simpleslidesPictureParameter\c!rulethickness);

  label.bot(btex \important{Non-reward nodes} etex, 
            (1.2*OverlayWidth/10, 2.2*OverlayHeight/10)) ;

\fi

setbounds currentpicture to OverlayBox ;

\stopuseMPgraphic
\protect

\IncludePicture
  [horizontal]
  [fig-mdp]
  [highlight=yes,
   page=1,
   color=orange,
   shadow=yes,
   grid=no]
  {Graphical Models --- Variable nodes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\unprotect
\startuseMPgraphic{simpleslides:MP:setup}
\ifconditional \simpleslidesHighlight
  \ifconditional \simpleslidesGrid
	\includeMPgraphic{simpleslides:MP:highlight:grid}
    \ifconditional \simpleslidesSubGrid
      \includeMPgraphic{simpleslides:MP:highlight:subgrid}%
    \fi
  \fi

  save p; path p;
  p := fullsquare xyscaled 
        % The dimensions are divided by 5 rather than 10, since the scale 
        % measures the radius, rather than the diameter.
        (4*OverlayWidth/5, 1.2*OverlayHeight/5)
       shifted
       (5.8*OverlayWidth/10, 1*OverlayHeight/10)  ;
  
  \ifcase \simpleslidesShadow \else
  
  save shadow_direction ; pair shadow_direction ;
  shadow_direction =\simpleslidesPictureParameter\c!rulethickness * 
     \ifcase \simpleslidesShadow \or
          (-1,1) \or (1,1) \or (1,-1) \or (-1,-1) \fi ;


  save shadow_thickness ; numeric shadow_thickness ;
  shadow_thickness := 2.7\simpleslidesPictureParameter\c!rulethickness ;

  def shadow_draw = draw enddef ;

  \includeMPgraphic{simpleslides:MP:highligh:shadow}
  \fi

  \ifcase \simpleslidesShadow \else
  
  save shadow_direction ; pair shadow_direction ;
  shadow_direction =\simpleslidesPictureParameter\c!rulethickness * 
     \ifcase \simpleslidesShadow \or
          (-1,1) \or (1,1) \or (1,-1) \or (-1,-1) \fi ;


  save shadow_thickness ; numeric shadow_thickness ;
  shadow_thickness := 2.7\simpleslidesPictureParameter\c!rulethickness ;

  def shadow_draw = draw enddef ;

  \includeMPgraphic{simpleslides:MP:highligh:shadow}
  \fi

  draw p withcolor \MPcolor{\simpleslidesPictureParameter\c!color} 
       withpen pencircle scaled (\simpleslidesPictureParameter\c!rulethickness);

  label.bot(btex \important{Control Factors} etex, 
            (5.8*OverlayWidth/10, -0.6*OverlayHeight/10)) ;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  p := fullsquare xyscaled 
        % The dimensions are divided by 5 rather than 10, since the scale 
        % measures the radius, rather than the diameter.
        (4.8*OverlayWidth/5, 1.3*OverlayHeight/5)
       shifted
       (5*OverlayWidth/10, 6.3*OverlayHeight/10)  ;
  
  \ifcase \simpleslidesShadow \else
  
  save shadow_direction ; pair shadow_direction ;
  shadow_direction =\simpleslidesPictureParameter\c!rulethickness * 
     \ifcase \simpleslidesShadow \or
          (-1,1) \or (1,1) \or (1,-1) \or (-1,-1) \fi ;


  save shadow_thickness ; numeric shadow_thickness ;
  shadow_thickness := 2.7\simpleslidesPictureParameter\c!rulethickness ;

  def shadow_draw = draw enddef ;

  \includeMPgraphic{simpleslides:MP:highligh:shadow}
  \fi

  draw p withcolor \MPcolor{\simpleslidesPictureParameter\c!color} 
       withpen pencircle scaled (\simpleslidesPictureParameter\c!rulethickness);

  label.bot(btex \important{Stochastic Factors} etex, 
            (4*OverlayWidth/10, 8.5*OverlayHeight/10)) ;

\fi

setbounds currentpicture to OverlayBox ;

\stopuseMPgraphic
\protect

\IncludePicture
  [horizontal]
  [fig-mdp]
  [highlight=yes,
   page=1,
   color=orange,
   shadow=yes,
   grid=no]
  {Graphical Models --- Factor nodes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\unprotect
\startuseMPgraphic{simpleslides:MP:setup}
\ifconditional \simpleslidesHighlight
  \ifconditional \simpleslidesGrid
	\includeMPgraphic{simpleslides:MP:highlight:grid}
    \ifconditional \simpleslidesSubGrid
      \includeMPgraphic{simpleslides:MP:highlight:subgrid}%
    \fi
  \fi

  save p; path p;
  p := fullcircle xyscaled 
        % The dimensions are divided by 5 rather than 10, since the scale 
        % measures the radius, rather than the diameter.
        (2.2*OverlayWidth/5, 1.2*OverlayHeight/5)
       shifted
       (2.7*OverlayWidth/10, 3.7*OverlayHeight/10)  ;
  
  \ifcase \simpleslidesShadow \else
  
  save shadow_direction ; pair shadow_direction ;
  shadow_direction =\simpleslidesPictureParameter\c!rulethickness * 
     \ifcase \simpleslidesShadow \or
          (-1,1) \or (1,1) \or (1,-1) \or (-1,-1) \fi ;


  save shadow_thickness ; numeric shadow_thickness ;
  shadow_thickness := 2.7\simpleslidesPictureParameter\c!rulethickness ;

  def shadow_draw = draw enddef ;

  \includeMPgraphic{simpleslides:MP:highligh:shadow}
  \fi

  draw p withcolor \MPcolor{\simpleslidesPictureParameter\c!color} 
       withpen pencircle scaled (\simpleslidesPictureParameter\c!rulethickness);

  label.bot(btex \important{Parents} etex, 
            (1*OverlayWidth/10, 2.6*OverlayHeight/10)) ;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  p := fullcircle xyscaled 
        % The dimensions are divided by 5 rather than 10, since the scale 
        % measures the radius, rather than the diameter.
        (.35*OverlayWidth/5, 0.35*OverlayWidth/5)
       shifted
       (5.8*OverlayWidth/10, 3.7*OverlayHeight/10)  ;
  
  \ifcase \simpleslidesShadow \else
  
  save shadow_direction ; pair shadow_direction ;
  shadow_direction =\simpleslidesPictureParameter\c!rulethickness * 
     \ifcase \simpleslidesShadow \or
          (-1,1) \or (1,1) \or (1,-1) \or (-1,-1) \fi ;


  save shadow_thickness ; numeric shadow_thickness ;
  shadow_thickness := 2.7\simpleslidesPictureParameter\c!rulethickness ;

  def shadow_draw = draw enddef ;

  \includeMPgraphic{simpleslides:MP:highligh:shadow}
  \fi

  draw p withcolor \MPcolor{\simpleslidesPictureParameter\c!color} 
       withpen pencircle scaled (\simpleslidesPictureParameter\c!rulethickness);

  label.rt(btex \important{Children} etex, 
            (6*OverlayWidth/10, 4.5*OverlayHeight/10)) ;

  autoarrows := true ;
  z1 = (6*OverlayWidth/10, 0.3*OverlayHeight/10) ;
  z2 = z1 + 4cm * dir(-30) ;

  p := z2 -- z1 ;

  \ifcase \simpleslidesShadow \else
  save shadow_direction ; pair shadow_direction ;
  shadow_direction = 2*\simpleslidesPictureParameter\c!rulethickness * 
     dir(%\simpleslidesPictureParameter{direction} +
     \ifcase \simpleslidesShadow \or 
          135 \or 45 \or -45 \or -135 \fi ) ;

  save shadow_thickness ; numeric shadow_thickness ;
  shadow_thickness := 2*\simpleslidesPictureParameter\c!rulethickness ;

  def shadow_draw = drawarrow enddef ;

  \includeMPgraphic{simpleslides:MP:highligh:shadow}
  \fi

  drawarrow p
       withcolor \MPcolor{\simpleslidesPictureParameter\c!color} 
       withpen pencircle scaled (2*\simpleslidesPictureParameter\c!rulethickness);

  label.rt(btex \important{Control factor node} etex, 
            (8.0*OverlayWidth/10, -2.5*OverlayHeight/10)) ;

\fi

setbounds currentpicture to OverlayBox ;

\stopuseMPgraphic
\protect

\IncludePicture
  [horizontal]
  [fig-mdp]
  [highlight=yes,
   page=1,
   color=orange,
   shadow=yes,
   grid=no]
  {Graphical Models --- Parents and Children}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\unprotect
\startuseMPgraphic{simpleslides:MP:setup}
\ifconditional \simpleslidesHighlight
  \ifconditional \simpleslidesGrid
	\includeMPgraphic{simpleslides:MP:highlight:grid}
    \ifconditional \simpleslidesSubGrid
      \includeMPgraphic{simpleslides:MP:highlight:subgrid}%
    \fi
  \fi

  save p; path p;

  p := ( (0.5*OverlayWidth/10, 3.5*OverlayHeight/10) ..
         (0.5*OverlayWidth/10, 8  *OverlayHeight/10) --
         % (2.5*OverlayWidth/10, 10.5 *OverlayHeight/10) ..
         (4.5*OverlayWidth/10, 8  *OverlayHeight/10) ..
         (4.5*OverlayWidth/10, 3.5*OverlayHeight/10) ..
         (2.5*OverlayWidth/10, -0.5*OverlayHeight/10) .. 
         cycle ) ;
  
  \ifcase \simpleslidesShadow \else
  
  save shadow_direction ; pair shadow_direction ;
  shadow_direction =\simpleslidesPictureParameter\c!rulethickness * 
     \ifcase \simpleslidesShadow \or
          (-1,1) \or (1,1) \or (1,-1) \or (-1,-1) \fi ;


  save shadow_thickness ; numeric shadow_thickness ;
  shadow_thickness := 2.7\simpleslidesPictureParameter\c!rulethickness ;

  def shadow_draw = draw enddef ;

  \includeMPgraphic{simpleslides:MP:highligh:shadow}
  \fi

  draw p withcolor \MPcolor{\simpleslidesPictureParameter\c!color} 
       withpen pencircle scaled (\simpleslidesPictureParameter\c!rulethickness);

  label.bot(btex \important{Ancestors} etex, 
            (2.5*OverlayWidth/10, -0.8*OverlayHeight/10)) ;
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  p := ( (5.5*OverlayWidth/10, 3.5*OverlayHeight/10) ..
         (5.5*OverlayWidth/10, 9.2*OverlayHeight/10) ..
         (7.5*OverlayWidth/10, 10.5*OverlayHeight/10) ..
         (9.5*OverlayWidth/10, 9.2*OverlayHeight/10) ..
         (9.5*OverlayWidth/10, 0  *OverlayHeight/10) ..
         (7.5*OverlayWidth/10, 0  *OverlayHeight/10) ..
         cycle ) ;

  \ifcase \simpleslidesShadow \else
  
  save shadow_direction ; pair shadow_direction ;
  shadow_direction =\simpleslidesPictureParameter\c!rulethickness * 
     \ifcase \simpleslidesShadow \or
          (-1,1) \or (1,1) \or (1,-1) \or (-1,-1) \fi ;


  save shadow_thickness ; numeric shadow_thickness ;
  shadow_thickness := 2.7\simpleslidesPictureParameter\c!rulethickness ;

  def shadow_draw = draw enddef ;

  \includeMPgraphic{simpleslides:MP:highligh:shadow}
  \fi

  draw p withcolor \MPcolor{\simpleslidesPictureParameter\c!color} 
       withpen pencircle scaled (\simpleslidesPictureParameter\c!rulethickness);

  label.top(btex \important{Descendants} etex, 
            (7.5*OverlayWidth/10, 10.7*OverlayHeight/10)) ;

  autoarrows := true ;
  z1 = (6*OverlayWidth/10, 0.3*OverlayHeight/10) ;
  z2 = z1 + 4cm * dir(-30) ;

  p := z2 -- z1 ;

  \ifcase \simpleslidesShadow \else
  save shadow_direction ; pair shadow_direction ;
  shadow_direction = 2*\simpleslidesPictureParameter\c!rulethickness * 
     dir(%\simpleslidesPictureParameter{direction} +
     \ifcase \simpleslidesShadow \or 
          135 \or 45 \or -45 \or -135 \fi ) ;

  save shadow_thickness ; numeric shadow_thickness ;
  shadow_thickness := 2*\simpleslidesPictureParameter\c!rulethickness ;

  def shadow_draw = drawarrow enddef ;

  \includeMPgraphic{simpleslides:MP:highligh:shadow}
  \fi

  drawarrow p
       withcolor \MPcolor{\simpleslidesPictureParameter\c!color} 
       withpen pencircle scaled (2*\simpleslidesPictureParameter\c!rulethickness);

  label.rt(btex \important{Control factor node} etex, 
            (8.0*OverlayWidth/10, -2.5*OverlayHeight/10)) ;

\fi

setbounds currentpicture to OverlayBox ;

\stopuseMPgraphic
\protect

\IncludePicture
  [horizontal]
  [fig-mdp]
  [highlight=yes,
   page=1,
   color=orange,
   shadow=yes,
   grid=no]
  {Graphical Models --- Ancestors and descendents}


\defineoverlay[simpleslides:background:highlight]
              [\useMPgraphic{simpleslides:MP:highlight}]%


\SlideTitle Structural results

\startitemize
  \head The main idea

    \startalignment[middle]
      If some data available at a DM is independent of future rewards given the
      control action and other data at the DM, then that data can be ignored
    \stopalignment

    \startimportant
      Can we automate this process?
    \stopimportant

\stopitemize

\Interlude \switchtobodyfont[20pt] \setupinterlinespace
        Struct. result $\equiv$ cond.\ independence \blank[big]
        Graphical models can easily test conditional independence

\SlideTitle Conditional independence 

\startitemize
  \head Three canonical graphs to verify $x \INDEPENDENT z \mid y$

    \vskip -3\baselineskip

    \placefigure[here,none]{}
    \startcombination[3]
      {\externalfigure[fig-ind][page=1]}
      {\externalfigure[face-smile][location=middle] Markov chain}
      {\externalfigure[fig-ind][page=2]}
      {\externalfigure[face-smile][location=middle] Hidden cause}
      {\externalfigure[fig-ind][page=3]}
      {\llap{\externalfigure[face-sad][location=middle]} Explanation }
    \stopcombination

  \head Blocking of a trail

    \vskip -.5\baselineskip
    A trail from $a$ to $b$ is blocked by $C$ if $\exists$ a node $v$ on the
    trail such that either:
    \vskip -.5\baselineskip
    \startitemize[1]
      \item either $\to v \to$, $\from v \from$, or $\from v \to$, and $v \in C$
      \item $\to v \from$ and neither $v$ nor any of $v$'s descendants are in
        $C$.
    \stopitemize
\stopitemize

\SlideTitle Conditional independence 

\startitemize

  \head d-separation

    $A$ is d-separated from $B$ by $C$ if all trails from $A$ to $B$ are blocked
    by $C$

  \head Conditional independence

    For any probability measure $P$ that factorizes according to a DAFG, 
    
    \blank[medium]
    \startalignment[middle]
      $A$ d-separated from $B$ by $C$ implies \crlf
      $X_A$ is conditionally independent
      of $X_B$ given $X_C$, $P$~a.s.
    \stopalignment

  \head Efficient algorithms to verify d-separation

    \vskip -1\baselineskip
    \startitemize
      \item Moral graph
        \hskip 5em
      \symbol[2]\space Bayes Ball
    \stopitemize

\stopitemize

\SlideTitle Automated Structural results

\startitemize
  \head First attempt

    \startitemize[unpacked]
      \item \emph{Dependent rewards:} $R_d(\tilde n) = R \cap
        \DESCENDANTS{\tilde n}$

      \item \emph{Irrelevant data:} At a control node $\tilde n$, and parent $i$
        is irrelevant if $R_d(\tilde n)$ is d-separate from $i$ given
        $\PARENTS{\tilde n} \cup \CHILDREN{\tilde n} \setminus \{i\}$

      \item \emph{Requisite data:} All parents that are not irrelevant
    \stopitemize

  \head Structural result

    \startitemize
      \item Without loss of optimality, we can remove irrelevant data. 
        \startformula
         \important{u_n = g_n(\text{requisite}(\tilde n))}
        \stopformula
    \stopitemize
    


\stopitemize
  
\SlideTitle 

\startshowresult{Structural Results for MDP --- Step 1}{1}
\startitemize
  \head Pick node $g_3$.

    \startitemize
      \item Original $u_3 = g_3(x_1, x_2, x_3, u_1, u_2)$
      \item requisite($g_3$) = $\{x_3\}$
      \item Thus, $u_3 = g_3(x_3)$
    \stopitemize
\stopitemize
\stopshowresult

\startshowresult{Structural Results for MDP --- Step 2}{2}
\startitemize
  \head Pick node $g_2$.

    \startitemize
      \item Original $u_2 = g_2(x_1, x_2, u_1)$
      \item requisite($g_2$) = $\{x_2\}$
      \item Thus, $u_2 = g_2(x_2)$
    \stopitemize
\stopitemize
\stopshowresult


\SlideTitle Structural Results for MDP --- Simplified

\placefigure[here,none]{}
  {\externalfigure[fig-mdp][page=3, width=0.8\textwidth]}

\Interlude \switchtobodyfont[20pt] \setupinterlinespace
  \important{$u_n = g_n($requisite$(\tilde n)$)} \crlf
  \blank[big]
  Does not work for all problems  \unknown{} \crlf
  \important{even when structural simplification is possible}

\SlideTitle A real-time source coding problem

\startitemize[paper]
  \item Hans S.\ Witsenhausen, 
    \emph{On the structure of real-time source coders}, \crlf
    Bell Systems Technical Journal, 
    vol 58, no 6, pp 1437-1451, July-August 1979
\stopitemize


\startitemize
  \head Mathematical Model

    \startitemize
      \item Source: First order Markov source $\{x_t$, $t=1,\dots\}$ 
      \item Real-time source coder: $y_t = c_t(x(1:t), y(1:t-1))$
      \item Finite memory decoder: $\hat x_t = g_t(y_t, m_{t-1})$
      \item \hphantom{Finite memory decoder} $m_{t} = l_t(y_t, m_{t-1})$
      \item Cost: $d_t = ρ_t(x_t, \hat x_t)$
    \stopitemize

\stopitemize

\IncludePicture
  [horizontal]
  [fig-rt]
  {Model for real-time comm --- Does not simplify}

\Interlude Need to take care of deterministic variables!

\SlideTitle Functionally determined nodes

\startitemize
  \head Functionally determined 

    \vskip -1.5\baselineskip
    \startitemize
      \item $X_B$ is functionally determined by $X_A$ if
        \emph{$X_B \INDEPENDENT X_N \mid X_A$}
    \stopitemize

    \head Conditional independence with functionally determined nodes

    \vskip -1\baselineskip
      \startitemize
        \item Can be checked using \important{D-separation}
        \item Similar to d-sep: in the defn of blocking change
          \quotation{in $C$} by \rlap{\quotation{is func detm by $C$}}
      \stopitemize

  \head Blocking of a trail (version that takes care of detm nodes)

    \vskip -.5\baselineskip
    A trail from $a$ to $b$ is blocked by $C$ if $\exists$ a node $v$ on the
    trail such that either:
    \vskip -.5\baselineskip
    \startitemize[1]
      \item either $\to v \to$, $\from v \from$, or $\from v \to$, and \emph{$v$ is functionally determined by $C$}
      \item $\to v \from$ and neither $v$ nor any of $v$'s descendants are in
        $C$.
    \stopitemize
\stopitemize

\SlideTitle Automated Structural results

\startitemize
  \head Second attempt

    \startitemize[unpacked]
      \item \emph{Irrelevant data:} Change d-separation by D-separation
        
      \item \emph{Requisite data:} All parents that are not irrelevant
    \stopitemize

  \head Structural result

    \startitemize
      \item Without loss of optimality, we can remove irrelevant data and add
        \important{appropriate} functionally determined data
        \blank
        \centerline{$u_n =
        g_n($requisite$(\tilde n)$, \important{functionally\_detm($\tilde n$)
        $\cap$ ancestors($R_d(\tilde n)$)}$)$}
    \stopitemize
     % \startimportant
     %   Proof: use policy independence of conditional expectation and
     %   follow the steps of the three step lemma.
     % \stopimportant
\stopitemize

\IncludePicture
  [horizontal]
  [fig-rt]
  {Lets try this!}

% \IncludePicture
%   [horizontal]
%   [fig-rt-cycle]
%   [highlight=yes,
%   alternative=focus,
%   x=3.25,
%   y=4,
%   xscale=2.1,
%   yscale=2,
%   direction=-45]
%   {Can lead to cycles}
% 
% \SlideTitle Automated Structural results
% 
% \startitemize
%   \head Third attempt
% 
%     \startitemize[unpacked]
%       \item \emph{Effectively observed:}:
%         functionally\_determined($\tilde n) \setminus \ANCESTORS{R_d(\tilde
%         n)}$
%     \stopitemize
% 
%   \head Structural result
% 
%     \startitemize
%       \item Without loss of optimality, we can choose \crlf
%         \centerline{$u_n =
%         g_n($requisite$(\tilde n)$, \important{effective\_obs($\tilde n$)$)$}}
%     \stopitemize
% 
% \stopitemize
% 
% \SlideTitle Automated Structural results
% 
% \startitemize
%   \head Third attempt
% 
%     \startitemize[unpacked]
%       \item \emph{Effectively observed:}:
%         Functionally determined at $\tilde n \setminus \ANCESTORS{R_d(\tilde
%         n)}$
%     \stopitemize
% 
%   \head Structural result
% 
%     \startitemize
%       \item Without loss of optimality, we can choose \crlf
%         \centerline{$u_n =
%         g_n($requisite$(\tilde n)$, \important{effective\_obs($\tilde n$)$)$}}
%     \stopitemize
% 
%     \startimportant
%       Works! Proof: use policy independence of conditional expectation and
%       follow the steps of the three step lemma.
%     \stopimportant
% 
% \stopitemize

\dorecurse{14}{
\IncludePicture
  [horizontal]
  [fig-rt]
  [page=\the\numexpr#1+1]
  {Structural Results for Dec MDP --- Step #1}}

\SlideTitle Structural Results for real-time communication

\startitemize
  \head Graphically

    \vskip -2\baselineskip
    \placefigure[here,none]{}
      {\externalfigure[fig-rt][page=15, width=0.8\textwidth]}

    \head Mathematically

      \startitemize
        \item Original Encoder:
          \important{$y_t = c_t(x_1, \dots, x_t, y_1, \dots, y_{t-1})$}

        \item New encoder: 
          \important{$y_t = c_t(x_t, m_{t-1})$}

      \stopitemize
\stopitemize

\SlideTitle Automated Structural results

\startitemize
  \head Simplify Once

    \startitemize
      \item For each control node
        \startitemize
          \item Find irrelevant nodes and functionally determined nodes.
          \item Remove edges from irrelevant nodes, add edges from functionally
            determined nodes.
        \stopitemize
    \stopitemize

  \head Find fixed point

    \startitemize
      \item Keep on simplifying until the graph does not change
    \stopitemize

  \head Software Implementation

    \startitemize
      \item A EDSL to find structural results \crlf
        \centerline{\tt
        \hyphenatedurl{http://pantheon.yale.edu/~am894/code/teams/}}
    \stopitemize
\stopitemize

\Interlude Conclusion

\SlideTitle Conclusion

\startimportant
  An automated method to derive structural results for sequential teams
\stopimportant

\startitemize
  \head Future Directions

    \startitemize
      \item Belief States
      \item Sequential decomposition
    \stopitemize

\stopitemize

\vfill

\Interlude \important{Thank you}


\stoptext
